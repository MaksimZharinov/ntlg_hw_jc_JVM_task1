# Домашнее задание
## Задача 1
### Код для разбора и описания:

```
public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}
```
#### Пункт 0:
Первым делом запускается подсистема загрузчика классов.
Состоит эта подсистема из трёх основных загрузчиков:
- Application ClassLoader
- Platform ClassLoader
- Bootstrap ClassLoader

Ещё можно написать свои загрузчики, пользовательские.

Происходит проверка классов на валидность кода, подготовка примитивов в статических полях,
связывание ссылок на другие классы.
Затем происходит инициализация классов. Выполняются static инициализаторы и инициализаторы 
static полей.
Если класс не был найден загрузчиками, что выбрасывается исключение.

Затем подготовленные классы загружаются в область памяти - Metaspace.
В этой области памяти хранятся данные о классе (имена, методы, поля) и константы.
Размер Metaspace можно настраивать.

Существуют ещё две области памяти:
- Стек (stack)
- Куча (heap)

В стеке хранятся методы, локальные переменные и ссылки на объекты в куче.
Размер стека ограничен. Методы хранятся во фреймах стека. Когда создаётся новый фрейм,
он помещается на вершину стека и становится активным, т.е. управление передаётся этому фрейму.
Когда метод заканчивает свою работу, его фрейм удаляется, автоматически освобождая память, 
и возвращает управление туда, откуда о его взял.

В куче хранятся объекты и ссылочные типы данных (ссылки на них хранятся в стеке).
Размер кучи можно регулировать. Память кучи автоматически не освобождается.
Куча разбита на несколько более мелких частей, называемых поколениями:
- Young Generation
- Old Generation
- Permanent Generation

Эти части служат для корректной работы Сборщика Мусора (Garbage Collector).

Сборщик мусора освобождает память кучи, останавливая все потоки программы и проверяя,
какие объекты не используются. При проверке используется два основных метода:
- Подсчёт ссылок
- Обход графа достижимых объектов

Недостижимые объекты удаляются, а достижимые группируются по времени жизни.
Эти группы и называются поколениями, на которые разделена куча.

Чем дольше живёт объект, тем реже его проверяет сборщик мусора.
Чем больше проверок пережил объект, тем он старше, и группируется в подходящую группу.

#### Пункт 0.1:
Класс JvmComprehension загружен, его статические поля и методы загружены.
В стеке выделилось место под метод main().
#### Пункт 1:
В стеке, во фрейме main() создаётся примитивная локальная переменная i типа int.
#### Пункт 2:
В куче создаётся объект типа Object, ссылка на который находится в переменной о 
типа Object. Сама переменная о создаётся в стеке, во фрейме main.
#### Пункт 3:
В куче создаётся объект типа Integer, ссылка на который хранится в
созданной в стеке в переменной ii.
#### Пункт 4:
В стеке создаётся новый фрейм для метода printAll, который помещается на вершину стека.
В момент вызова, в этом фрейме создаются локальные переменные типа:
- o типа Object
- i типа int
- ii типа Integer
В них заносятся ссылки на объекты из кучи или присваиваются значения, в зависимости от типа переменной.
#### Пункт 5:
Во фрейме printAll создаётся переменна типа Integer и инициализируется, в куче создаётся объект типа Integer.
#### Пункт 6:
В стеке создаётся фрейм для метода System.out.println, в этом фрейме создаются переменные:
- о типа Object
- i типа int
- ii типа Integer 

Создаётся ещё один фрейм для метода toString у объекта о.

В куче создаётся объект типа String, куда записывается результат метода о.toString.
Ссылка на этот объект передаётся во фрейм метода println, toString завершает свою работу.

Во фрейме println происходит конкатенация, в куче создаётся новый объект String.
Затем этот объект в виде строки отправляется в поток вывода и печатается в терминале.

Метод println завершается и передаёт управление во фрейм printAll.

printAll завершается и передаёт управление в main.
#### Пункт 7:
Создаётся новый фрейм println, который выводит на печать строку "finished".

Фрейм println завершает свою работу, отдаёт управление в main. 

main завершает свою работу.

Весь поток завершает свою работу.





